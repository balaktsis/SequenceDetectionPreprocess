package auth.datalab.sequenceDetection.CommandLineParser

import scopt.{OParser, OParserBuilder}

import scala.language.postfixOps

case class Config(
                   mode: String = "siesta",
                   filename: String = "synthetic",
                   delete_all: Boolean = false,
                   delete_previous: Boolean = false,
                   join: Boolean = false,
                   algorithm: String = "indexing",
                   traces: Int = 100,
                   event_types: Int = 10,
                   length_min: Int = 10,
                   length_max: Int = 90,
                   iterations: Int = -1,
                   n: Int = 2,
                   k:Int = -1

                   //                     kwargs: Map[String, String] = Map()
                 )

object ParsingArguments {
  val builder: OParserBuilder[Config] = OParser.builder[Config]
  val parser: OParser[Unit, Config] = {
    import builder._
    OParser.sequence(
      programName("preprocess.jar"),
      head("SIESTA preprocess"),
      opt[String]('m', "mode")
        .action((x, c) => c.copy(mode = x))
        .valueName("<mode>")
        .validate(x => {
          if (x.equals("siesta") || x.equals("signature") || x.equals("setcontainment")) {
            success
          } else {
            failure("Value <mode> must be either siesta, signature or setcontainment")
          }
        })
        .text("Mode is the name of the method used"),
      opt[String]('f', "file")
        .action((x, c) => c.copy(filename = x))
        .valueName("<file> ")
        .text("If not set will generate artificially data"),
      opt[Unit]("delete_all")
        .action((_, c) => c.copy(delete_all = true))
        .text("cleans all tables in the keyspace"),
      opt[Unit]("delete_prev")
        .action((_, c) => c.copy(delete_previous = true))
        .text("removes all the tables generated by a previous execution of this method"),
      opt[Unit]("join")
        .action((_, c) => c.copy(join = true))
        .text("merges the traces with the already indexed ones"),
      opt[Int]("n")
        .valueName("<n>")
        .text("Key size (n-tuples)")
        .validate(x=>{
          if(x>0 && x<4) success else failure("Value <n> has to be between 1 and 3")
        })
        .action((x,c)=>c.copy(n=x)),
      opt[Int]("k")
        .valueName("<k>")
        .text("Number of frequent pairs used in Signature")
        .validate(x=>{
          if(x>0) success else failure("Value <k> has to be positive")
        })
        .action((x,c)=>c.copy(k=x)),
      opt[Int]('i',"iterations")
        .valueName("<i>")
        .text("# iterations, if not set it will be determined by the system")
        .validate(x=> if(x>0) success else failure("Value <i> has to be a positive integer"))
        .action((x,c)=>c.copy(iterations = x)),
      note( sys.props("line.separator")+"The parameters below are used if the file was not set and data will be randomly generated" ),
      opt[Int]('t', "traces")
        .valueName("<#traces>")
        .validate(x => {
          if (x > 0) success else failure("Value <#traces> must be positive")
        })
        .action((x, c) => c.copy(traces = x)),
      opt[Int]('e', "event_types")
        .valueName("<#event_types>")
        .validate(x => {
          if (x > 0) success else failure("Value <#event_types> must be positive")
        })
        .action((x, c) => c.copy(event_types = x)),
      opt[Int]("lmin")
        .valueName("<min length>")
        .action((x, c) => c.copy(length_min = x)),
      opt[Int]("lmax")
        .valueName("<max length>")
        .action((x, c) => c.copy(length_max = x)),
      help("help").text("prints this usage text")
    )
  }

  def parseArguments(args: Array[String]): Option[Config] = {
    OParser.parse(parser, args, Config()) match {
      case Some(config) =>
        Some(config)
      case _ =>
        println("There was an error with the arguments. Use 'help' to display full list of arguments")
        null
    }
  }


}
